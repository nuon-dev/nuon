import { AIChat, ChatType } from "../entity/ai/aiChat"
import { AIChatRoom } from "../entity/ai/aiChatRoom"
import { User } from "../entity/user"
import dataSource, { aiChatRoomDatabase } from "./dataSource"

/*
 * AI와 주고받는 메시지 타입 정의
 */
interface MessageType {
  role: "user" | "assistant" | "system"
  content: string
}

interface AiChatResponse {
  id: string
  content: Array<{
    citations: any
    text: string
    type: string
  }>
  model: string
  role: string
  stop_reason: string | null
  stop_sequence: string | null
  type: string
  usage: any
}

const AiModel = {
  async createNewRoom(user: User, title: string): Promise<AIChatRoom> {
    if (title.length > 100) {
      title = title.slice(0, 100)
    }
    const room = await aiChatRoomDatabase.create({
      user: user,
      title: title,
    })
    await aiChatRoomDatabase.save(room)
    return room
  },

  async getUserRooms(user: User) {
    const rooms = await aiChatRoomDatabase.find({
      where: {
        user: {
          id: user.id,
        },
      },
    })
    return rooms
  },

  async callSql(query: string) {
    const sqlMatch = query.match(/```(?:sql)?\s*([\s\S]*?)\s*```/i)
    const sql = sqlMatch ? sqlMatch[1] : query

    const result = await dataSource.query(sql)
    return result
  },

  async requestChatAI(messages: AIChat[]) {
    // Separate system prompt (assumed to be the first message if it's SYSTEM type)
    let systemPrompt = await getSystemPrompt()
    let chatMessages = [...messages]

    const body = {
      model: "claude-sonnet-4-5-20250929",
      max_tokens: 1024,
      system: systemPrompt,
      messages: chatMessages.map((chat) => {
        let role: "user" | "assistant" = "user"
        switch (chat.type) {
          case ChatType.USER:
            role = "user"
            break
          case ChatType.AI:
            role = "assistant"
            break
          case ChatType.SYSTEM:
            // Query Result is treated as User input (context for the AI)
            // SQL Query (generated by AI previously) is treated as Assistant output
            if (chat.message.startsWith("Query Result:")) {
              role = "user"
            } else {
              role = "assistant"
            }
            break
        }
        return {
          role: role,
          content: chat.message,
        }
      }),
    }

    console.log("AI 요청 본문:", JSON.stringify(body, null, 2))
    const response = await fetch(
      "https://factchat-cloud.mindlogic.ai/v1/api/anthropic/messages",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.AI_API_KEY}`,
        },
        body: JSON.stringify(body),
      }
    )
    const data = (await response.json()) as AiChatResponse
    console.log("AI 응답 전체:", data)

    if (!data.content || data.content.length === 0) {
      console.error("AI returned empty content", data)
      throw new Error("AI returned empty content")
    }

    return {
      type: ChatType.AI,
      message: data.content[0].text,
    } as AIChat
  },

  async getChatRoom(roomId: string, isSystemChatIncluded = false) {
    const chatRoom = await aiChatRoomDatabase.findOne({
      select: {
        id: true,
        title: true,
        createdAt: true,
        user: {
          id: true,
        },
        chats: {
          id: true,
          type: true,
          message: true,
          createdAt: true,
        },
      },
      where: {
        id: roomId,
      },
      relations: {
        chats: true,
        user: true,
      },
      order: {
        chats: { createdAt: "ASC" },
      },
    })
    if (!isSystemChatIncluded) {
      chatRoom.chats = chatRoom.chats.filter(
        (chat) => chat.type !== ChatType.SYSTEM
      )
    }
    return chatRoom
  },
}

async function getSystemPrompt(): Promise<string> {
  const schema = await dataSource.query(`
    SELECT 
    TABLE_NAME, 
    COLUMN_NAME, 
    DATA_TYPE,
    COLUMN_COMMENT
FROM 
    INFORMATION_SCHEMA.COLUMNS
WHERE 
    TABLE_SCHEMA = '${process.env.DB_NAME}'
ORDER BY 
    TABLE_NAME, 
    ORDINAL_POSITION;
    `)

  return `
    당신은 교회 수련회 및 공동체 관리 시스템의 데이터베이스 전문가 AI 비서입니다.
    사용자의 질문을 분석하여 통계를 내거나 정보를 찾기 위해 SQL 쿼리를 작성하고, 이후 제공되는 쿼리 결과를 분석하여 사용자에게 답변을 제공합니다.

    [데이터베이스 스키마 정보]
    ${JSON.stringify(schema, null, 2)}

    [작업 절차]
    1. 사용자의 질문이 데이터 조회가 필요한 경우, 표준 SQL(Mysql 호환) 쿼리를 작성해 주세요.
    - 쿼리는 반드시 \`\`\`sql ... \`\`\` 코드 블록 안에 작성해야 합니다.
    - 다른 설명 없이 오직 SQL 쿼리만 반환하는 것을 권장합니다.
    2. 만약 입력으로 "Query Result:" 와 함께 데이터가 주어진다면, 그 데이터를 분석하여 사용자의 원래 질문에 대해 친절하게 답변해 주세요.
    3. 조회 이외의 모든 쿼리 예(데이터 삽입, 수정, 삭제 등)은 절대 절대 금지 함으로 작성하지 마세요. 
    4. 쿼리 결과가 너무 많이 나오지 않도록 항상 적절한 제한을 걸어 주세요.
    5. 오늘 날짜는 ${new Date().getFullYear()}년 ${
    new Date().getMonth() + 1
  }월 ${new Date().getDate()}일 입니다.

    [예시]
    User: "저번주 주일예배 출석률 알려줘"
    Assistant: 
    \`\`\`sql
    SELECT count(*) as count, isAttend FROM AttendData 
    LEFT JOIN WorshipSchedule ON AttendData.worshipScheduleId = WorshipSchedule.id 
    WHERE WorshipSchedule.kind = 1 AND WorshipSchedule.date = '...' 
    GROUP BY isAttend
    \`\`\`
        `
}

export default AiModel
